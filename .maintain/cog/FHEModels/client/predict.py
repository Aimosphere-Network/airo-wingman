import joblib
import os
import subprocess
import numpy as np
from cog import BasePredictor, Input
from concrete.ml.deployment import FHEModelClient

# Suppose client has already interacted with server to get client.zip 
# In real world this file would be copied to client directory once before
client_fhe_file_dir = "../fhe"

# standard place and file name to store evaluation key
keys_file = "serialized_evaluation_keys.ekl"


class Predictor(BasePredictor):
    def setup(self):
        # Generate client from client.zip file from dev
        # client.zip is generated by dev (model owner) using dev.py script
        # if this does not work it os probably because the file was generated
        # in a different OS from this machine's
        self.client = FHEModelClient(client_fhe_file_dir)

        """Evaluation key generation"""
        
        # Create private and evaluation keys
        eval_key = self.client.get_serialized_evaluation_keys()

        # Export keys into file
        with open(keys_file, "wb") as f: f.write(eval_key)
    

    def predict(self, 
                features: str = Input(description="plain-text features file"),
                server_address: str = Input(description="server's remote host address")
                ) -> str:

        """Input encryption with evaluation key"""
        
        # Load features from file
        input_data = joblib.load(features)

        # Encrypt features individually
        enc_inputs = []
        for i in input_data:
            e_i = self.client.quantize_encrypt_serialize(i.reshape(1, -1))
            enc_inputs.append(e_i)

        # Export encrypted features to file
        base_name, ext = os.path.splitext(features) 
        enc_inputs_file = f"{base_name}{"_enc"}{ext}"
        joblib.dump(enc_inputs, enc_inputs_file)

        """Send request"""

        # Cog command to execute prediction on server
        # TODO: substitute by just sending both files through SSH and the server
        # running the command on it's own
        message = [ 'cog', 'predict', '-i', f'eval_key_file=@{keys_file}', '-i', f'enc_input_file=@{enc_inputs_file}']
        
        # SSH command to talk to server
        ssh_command = ['ssh', server_address, message]

        # Call for request
        request = subprocess.run(ssh_command, capture_output=True, text=True)

        """Receive response"""

        # Response is path for results file in server
        response = request.stdout

        # Command to copy results file from server
        scp_command = ['scp', f'{server_address}:{response}', ""]

        # Get results file
        enc_output_file = subprocess.run(scp_command, capture_output=True, text=True)

        # Load results from file
        enc_output = joblib.load(enc_output_file)

        """Output decryption with evaluation key"""

        # Decrypt results individually
        output_data = []
        for e_o in enc_output:
            o = np.argmax(self.client.deserialize_decrypt_dequantize(e_o), axis=1)
            output_data.append(o)

        # Print results
        print(output_data)

        # Print groud truths for comparisson
        # print(joblib.load(os.path.join("ground_truths", features)))